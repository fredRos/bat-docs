<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <!-- For Mobile Devices -->
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
        <meta name="generator" content="Doxygen 1.8.11"/>
        <script type="text/javascript" src="https://code.jquery.com/jquery-2.1.1.min.js"></script>
        <title>BAT manual: integration.md Source File</title>
        <!--<link href="tabs.css" rel="stylesheet" type="text/css"/>-->
        <script type="text/javascript" src="dynsections.js"></script>
        <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
        <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
MathJax.Hub.Config({
    TeX: {
        Macros: {
            cond: ["{\\,|\\,}"],
            rmdx: ["{\\mbox{d}#1\\,}",1],
            scath: ["{\\theta}"],
            vecth: ["{\\boldsymbol{\\theta}}"],
            order: ["{\\mathcal{O}(#1)}",1],
        }
    }
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/latest.js?config=TeX-MML-AM_CHTML/MathJax.js"></script>
        <link href="doxygen.css" rel="stylesheet" type="text/css" />
        <link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
        <link href='https://fonts.googleapis.com/css?family=Roboto+Slab' rel='stylesheet' type='text/css'>
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.1/css/bootstrap.min.css">
        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.1/js/bootstrap.min.js"></script>
        <script type="text/javascript" src="doxy-boot.js"></script>
    </head>
    <body>
        <nav class="navbar navbar-default" role="navigation">
            <div class="container">
                <div class="navbar-header">
                    <a class="navbar-brand">BAT manual 1.0.0-RC2</a>
                </div>
            </div>
        </nav>
        <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
            <div class="content" id="content">
                <div class="container">
                    <div class="row">
                        <div class="col-sm-12 panel " style="padding-bottom: 15px;">
                            <div style="margin-bottom: 15px;">
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Overview</span></a></li>
      <li><a href="pages.html"><span>Chapters</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">integration.md</div>  </div>
</div><!--header-->
<div class="contents">
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;Integration {#cha-integration}</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;============</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;[TOC]</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;@section sec-int-motiv Motivation</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;The reason that BAT exists is that nearly any Bayesian analysis</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;these days is too complicated to be handled analytically. To address</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;typical questions like</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;* What is known about a single parameter taking into account</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;  the uncertainty on all other parameters?</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;* How are parameters correlated?</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;one needs to be able to compute and visualize 1D and 2D *marginal distributions*; cf. @ref  sec-marginalization. These are defined as integrals over the posterior; for  example the 2D marginal distribution is</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;\f{align}{</div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;  \label{eq:int-marginal}</div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;  P(\theta_1, \theta_2 \cond D) = \int \prod_{i \ne 1,2} \rmdx{\theta_i} P(\vecth \cond D).</div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;\f}</div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;To do model comparison, one has to compute the evidence, that is the integral over all parameters</div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;\f{equation}{</div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;Z = \int \rmdx{ \vecth} P(D|\vecth, M) P(\vecth</div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;\cond M).</div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;\f}</div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;Therefore Bayesian inference in practice requires good integration techniques. These methods are bundled in the class `BCIntegrate` with the exception of the Markov chain code in `BCEngineMCMC`; see also the @ref cha-code-structure.</div><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;</div><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;For low-dimensional problems, deterministic integration methods are</div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;usually the fastest and most robust but for higher dimensions, Monte</div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;Carlo techniques are the most efficient tools known. Depending on the</div><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;setting, BAT defaults to deterministic methods for \f$d \le 2,3\f$</div><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;dimensions and uses Monte Carlo for \f$d&gt;3\f$.</div><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;</div><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;@section sec-int-marg Marginalization</div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;</div><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;The main use case for BAT is to estimate and visualize the marginal</div><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;distributions of the posterior. Given a model `m`, all marginal</div><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;distributions are estimated as histograms by</div><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;</div><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;@code{.cpp}</div><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;m.MarginalizeAll();</div><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;@endcode</div><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;</div><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;The individual distributions can be accessed using</div><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;</div><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;@todo snippet of 1D, par 2 vs 5</div><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;@todo show how to constrain which distributions are stored, useful if many nuisance parameters.</div><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;</div><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;The method for marginalizing can be selected as follows</div><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;</div><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;@code{.cpp}</div><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;m.SetMarginalizationMethod(method);</div><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;@endcode</div><div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;</div><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;where `method` is an `enum` in  `BCIntegrate::BCMarginalizationMethod`</div><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;</div><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;`method`  | Details</div><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;------------- | -------------</div><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;`kMargMetropolis`  | Metropolis algorithm; see @ref cha-mcmc.</div><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;`kMargMonteCarlo`  | Sample mean integration in each histogram bin. Least efficient method.</div><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;`kMargGrid` | Evaluate target at each bin center. Most efficient for 1D and 2D.</div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;`kMargDefault` | Use `kMargGrid` for \f$d \leq 2 \f$, else `kMargMetropolis`.</div><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;</div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;The availability of marginalization methods can be queried at runtime using `BCIntegrate::CheckMarginalizationAvailability`.</div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;</div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;In case any pre- or postprocessing needs to happen to set up data structures, we provide the hooks `virtual void BCIntegrate::MarginalizePreprocess` and `virtual void BCIntegrate::MarginalizePostprocess`. They are empty by default and can be overloaded in a user model.</div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;</div><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;@section sec-int-evidence Evidence</div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;</div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;In BAT terminology, the evidence or normalization constant of a model</div><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;`m` with the default method is computed as</div><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;</div><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;@code{.cpp}</div><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;double evidence = m.Normalize();</div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;@endcode</div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;</div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;This is the evidence on the linear scale. Choose the method of integration</div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;explicitly with</div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;</div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;@code{.cpp}</div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;double evidence = m.Integrate(method);</div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;@endcode</div><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;</div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;where `method` is an `enum` in `BCIntegrate::BCIntegrationMethod`.</div><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;</div><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;</div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;`BCIntegrationMethod`  | Details</div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;------------- | -------------</div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;`kIntMonteCarlo` | Sample mean. Usually least efficient.</div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;`kIntCuba` | Use a method from cuba.</div><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;`kIntGrid` | Approximate Riemann sum over a dense grid for \f$d \leq 3 \f$.</div><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;`kIntLaplace` | Laplace approxation. Only approximately valid for peaked unimodal integrands. Incorrect if distribution is heavy tailed or if the mode is near a boundary. Very fast. No uncertainty estimate. Only method implemented on the log scale.</div><div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;`kIntDefault` | Use Cuba if available. Else use `kIntGrid` for \f$d \leq 3 \f$ and `kIntMonteCarlo` for \f$d &gt; 3 \f$.</div><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;</div><div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;General termination criteria for all integration methods except `kIntLaplace` are the desired absolute precision \f$\epsilon_a\f$ and relative precision \f$\epsilon_r\f$ and the minimum and maximum number of iterations:</div><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;</div><div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;@code{.cpp}</div><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;m.SetAbsolutePrecision(1e-6);</div><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;m.SetRelativePrecision(1e-8);</div><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;m.SetNIterationsMin(2000);</div><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;m.SetNIterationsMax(50000);</div><div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;@endcode</div><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;</div><div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;The integration terminates if</div><div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;\f{equation}{</div><div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;|Z-\hat{Z}| \leq \max(\epsilon_a, \epsilon_r Z)</div><div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;\f}</div><div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;where \f$\hat{Z}\f$ is the current estimate of the evidence.</div><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;</div><div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;@subsection sec-int-rescale Rescaling</div><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;</div><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;In case the log likelihood is very small or very large, going to the linear</div><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;scale may take it to exactly zero or infinity in finite precision. This often</div><div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;happens in practice if the log likelihood is a sum of `N` terms. For example,</div><div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;assume each factor is 0.5. Then \f$\exp(0.5 N)=\infty\f$ on the computer for</div><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;\f$N \geq 1420\f$ using double precision. To avoid this problem, you can rescale</div><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;the log likelihood by manually subtracting the value at the mode inside `LogLikelihood`.</div><div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;</div><div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;Another option, if requirements are satisfied, is to use the Laplace method. It</div><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;is naturally implemented on the log scale. While the standard interface to all</div><div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;integration methods via `BCIntegrate::Normalize()` always transforms to the</div><div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;linear scale, calling `BCIntegrate::IntegrateLaplace()` directly returns the</div><div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;evidence on the log scale.</div><div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;</div><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;@subsection sec-int-cuba Cuba</div><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;</div><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;The Cuba package itself has four different integration methods. Cuba is an external dependency; see the installation instructions on how to build BAT with Cuba support. If Cuba is available, select the Cuba method with</div><div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;@code{.cpp}</div><div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;m.SetCubaIntegrationMethod(method);</div><div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;m.Integrate();</div><div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;// alternative</div><div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;m.IntegrateCuba(method);</div><div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;@endcode</div><div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;where `method` is an `enum` in `BCIntegrate::BCCubaMethod`</div><div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;</div><div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;`BCCubaMethod`  | Details</div><div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;------------- | -------------</div><div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;`kCubaVegas` | VEGAS algorithm by Lepage</div><div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;`kCubaSuave` | Suave algorithm.</div><div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;`kCubaDivonne` | Divonne algorithm.</div><div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;`kCubaCuhre` | Cuhre algorithm. Essentially quadrature in higher dimensions. Suffers from curse of dimensionality but most efficient and robust in low dimensions.</div><div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;`kCubaDefault` | For \f$d=1\f$, use VEGAS, for  \f$d=2,3\f$, use Cuhre, and for  \f$d&gt; 3\f$, use Divonne.</div><div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;</div><div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;Each Cuba method comes with various parameter values to set. We have</div><div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;taken over default values from the example that comes with Cuba but</div><div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;they are by no means optimal for every problem. Please experiment and</div><div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;consult the Cuba manual that comes with the Cuba source code from</div><div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;http://www.feynarts.de/cuba/. All options are accessible in the</div><div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;namespace `BCCubaOptions`. An example with bogus values</div><div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;</div><div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;@code{.cpp}</div><div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;BCCubaOptions::Suave o = m.GetCubaSuaveOptions();</div><div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;o.flatness = 5;</div><div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;o.nnew = 5000;</div><div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;o.nmin = 15;</div><div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;m.SetNIterationsMax(1e7);</div><div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;m.SetCubaOptions(o);</div><div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;m.IntegrateCuba(BCIntegrate::kCubaSuave);</div><div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;@endcode</div><div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;</div><div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;@section sec-int-slice Slices</div><div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;</div><div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;To get a quick visualization of a complicated posterior, a slice, or projection, may be preferable to a full marginalization. That is, all parameters except one  [two] are held fixed (instead of integrated over as in marginalization) and the remaining parameter[s] are evaluated on a regular grid. In other words, the conditional distribution</div><div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;</div><div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;\f{equation}{</div><div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;P(\theta_1 \cond \vecth_{\backslash 1}, D) = \frac{P(\vecth \cond D)} {P(\vecth_{\backslash 1} \cond D)} .</div><div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;\f}</div><div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;</div><div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;The slice is returned as one [two] dimensional histogram. This is achieved with the various variants of `BCIntegrate::GetSlice`.</div><div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;</div><div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;In a posterior where all parameters are independent, the marginal and conditional distributions coincide because</div><div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;</div><div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;\f{equation}{</div><div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;P(\theta_1 \cond \vecth_{\backslash 1}, D) = \frac{P(\vecth_{\backslash 1} \cond D) P(\theta_1 \cond D)} {P(\vecth_{\backslash 1} \cond D)}= P(\theta_1 \cond D) .</div><div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;\f}</div><div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;</div><div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;@note Independence rarely holds in practice, so marginalization is still useful.</div><div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;</div><div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;For example, in a Gaussian posterior with independent parameters, we first find the mode and use these parameter values to find the 1D conditional distribution of the first parameter. In this example, the result is just a Gaussian. Here is how to find the result in general, for non-Gaussian or non-independent posteriors:</div><div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;@code{.cpp}</div><div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;#include &lt;TH1.h&gt;</div><div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;#include &lt;TCanvas.h&gt;</div><div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;...</div><div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;int main()</div><div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;{</div><div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;...</div><div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;    m.FindMode(m.GetBestFitParameters());</div><div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;</div><div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;    TCanvas c;</div><div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;    unsigned nIterations;</div><div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;    double log_max;</div><div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;    int nbins = 100;</div><div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;    bool normalize = true;</div><div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;    TH1* slice = m.GetSlice(0, nIterations, log_max, m.GetBestFitParameters(), nbins, normalize);</div><div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;    slice-&gt;Draw(&quot;HISTSAME&quot;);</div><div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;    c.Print(&quot;slice.pdf&quot;);</div><div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;    delete slice;</div><div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;...</div><div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;}</div><div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;@endcode</div><div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;</div></div><!-- fragment --></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
</div>
</div>
</div>
</div>
</div>
<!-- <hr class="footer"/><address class="footer"><small> -->
<!-- Generated on Tue May 8 2018 13:18:40 for BAT manual by &#160;<a href="http://www.doxygen.org/index.html"> -->
<!-- <img class="footer" src="doxygen.png" alt="doxygen"/> -->
<!-- </a> 1.8.11 -->
<!-- </small></address> -->
</body>
</html>
